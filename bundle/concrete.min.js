/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	global.Concrete = __webpack_require__(1);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var guards = __webpack_require__(2);
	var consArray = __webpack_require__(4);
	var consDate = __webpack_require__(7);
	var consMap = __webpack_require__(8);
	var consObj = __webpack_require__(6);
	var consSet = __webpack_require__(9);
	__export(__webpack_require__(2));
	function from(obj) {
	    if (obj instanceof Map) {
	        return consMap.from(obj);
	    }
	    else if (obj instanceof Set) {
	        return consSet.from(obj);
	    }
	    else if (obj instanceof Date) {
	        return consDate.from(obj);
	    }
	    else if (typeof obj === "object") {
	        if (Array.isArray(obj)) {
	            return consArray.from(obj);
	        }
	        else if (obj.constructor === Object) {
	            return consObj.from(obj);
	        }
	    }
	    // throw new TypeError(`The given object type is not supported: ${obj}`);
	    return obj;
	}
	exports.from = from;
	function toMutable(obj) {
	    if (guards.isArray(obj)) {
	        return obj.toMutable();
	    }
	    else if (guards.isDate(obj)) {
	        return obj.toMutable();
	    }
	    else if (guards.isMap(obj)) {
	        return obj.toMutable();
	    }
	    else if (guards.isObject(obj)) {
	        return consObj.toMutable(obj);
	    }
	    else if (guards.isSet(obj)) {
	        return obj.toMutable();
	    }
	    // throw new TypeError(`The given object type is not supported: ${obj}`);
	    return obj;
	}
	exports.toMutable = toMutable;
	//# sourceMappingURL=index.js.map

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ConcreteStructure_1 = __webpack_require__(3);
	/**
	 *
	 */
	function is(obj) {
	    return !!obj && obj[ConcreteStructure_1.ConcreteStructureTypeKey] !== undefined;
	}
	exports.is = is;
	function isArray(obj) {
	    return is(obj) && obj[ConcreteStructure_1.ConcreteStructureTypeKey] === ConcreteStructure_1.ConcreteStructureType.ARRAY;
	}
	exports.isArray = isArray;
	function isDate(obj) {
	    return is(obj) && obj[ConcreteStructure_1.ConcreteStructureTypeKey] === ConcreteStructure_1.ConcreteStructureType.DATE;
	}
	exports.isDate = isDate;
	function isMap(obj) {
	    return is(obj) && obj[ConcreteStructure_1.ConcreteStructureTypeKey] === ConcreteStructure_1.ConcreteStructureType.MAP;
	}
	exports.isMap = isMap;
	function isObject(obj) {
	    return is(obj) && obj[ConcreteStructure_1.ConcreteStructureTypeKey] === ConcreteStructure_1.ConcreteStructureType.OBJECT;
	}
	exports.isObject = isObject;
	function isSet(obj) {
	    return is(obj) && obj[ConcreteStructure_1.ConcreteStructureTypeKey] === ConcreteStructure_1.ConcreteStructureType.SET;
	}
	exports.isSet = isSet;
	//# sourceMappingURL=guards.js.map

/***/ },
/* 3 */
/***/ function(module, exports) {

	"use strict";
	var StructureCacheKey = Symbol("StructureCacheKey");
	var StructureCache = new WeakMap();
	/**
	 *
	 */
	var ConcreteStructureType;
	(function (ConcreteStructureType) {
	    ConcreteStructureType[ConcreteStructureType["OBJECT"] = 0] = "OBJECT";
	    ConcreteStructureType[ConcreteStructureType["ARRAY"] = 1] = "ARRAY";
	    ConcreteStructureType[ConcreteStructureType["DATE"] = 2] = "DATE";
	    ConcreteStructureType[ConcreteStructureType["MAP"] = 3] = "MAP";
	    ConcreteStructureType[ConcreteStructureType["SET"] = 4] = "SET";
	    ConcreteStructureType[ConcreteStructureType["UNKNOWN"] = 5] = "UNKNOWN";
	})(ConcreteStructureType = exports.ConcreteStructureType || (exports.ConcreteStructureType = {}));
	/**
	 *
	 */
	exports.ConcreteStructureTypeKey = Symbol("ConcreteStructureType");
	/**
	 *
	 */
	var ConcreteStructure = (function () {
	    function ConcreteStructure() {
	    }
	    ConcreteStructure.prototype[exports.ConcreteStructureTypeKey] = function () {
	        return ConcreteStructureType.UNKNOWN;
	    };
	    return ConcreteStructure;
	}());
	exports.ConcreteStructure = ConcreteStructure;
	//# sourceMappingURL=ConcreteStructure.js.map

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var guards_1 = __webpack_require__(2);
	var ConcreteStructure_1 = __webpack_require__(3);
	var errors_1 = __webpack_require__(5);
	var consArray = __webpack_require__(6);
	var consDate = __webpack_require__(7);
	var consMap = __webpack_require__(8);
	var consSet = __webpack_require__(9);
	var _1 = __webpack_require__(1);
	var readOnlyErrorProp = {
	    value: function () { throw new errors_1.ReadonlyError("This method is not supported by Concrete arrays."); },
	};
	function from(arr) {
	    var sumCache;
	    arr = Object.defineProperties(arr, {
	        ConcreteStructureTypeKey: {
	            value: ConcreteStructure_1.ConcreteStructureType.ARRAY,
	        },
	        length: { value: arr.length },
	        copyWithin: readOnlyErrorProp,
	        fill: readOnlyErrorProp,
	        pop: readOnlyErrorProp,
	        push: readOnlyErrorProp,
	        reverse: readOnlyErrorProp,
	        shift: readOnlyErrorProp,
	        sort: readOnlyErrorProp,
	        splice: readOnlyErrorProp,
	        unshift: readOnlyErrorProp,
	        sum: {
	            value: function () {
	                if (sumCache === undefined) {
	                    sumCache = arr.reduce(function (p, c) { return p + (parseFloat(String(c)) || 0); }, 0);
	                }
	                return sumCache;
	            },
	        },
	        toMutable: function () {
	            return arr.map(function (v) { return _1.toMutable(v); });
	        },
	    });
	    // Proxify
	    arr = new Proxy(arr, {
	        get: function (oTarget, sKey) {
	            var value = oTarget[sKey];
	            var typeOf = typeof value;
	            if (value === undefined || value === null || typeOf === "function" || typeOf === "symbol") {
	                return value;
	            }
	            // If already Concrete, return.
	            if (guards_1.is(value)) {
	                return value;
	            }
	            // If not Concrete and supported object, make Concrete.
	            if (value instanceof Map) {
	                return consMap.from(value);
	            }
	            else if (value instanceof Set) {
	                return consSet.from(value);
	            }
	            else if (value instanceof Date) {
	                return consDate.from(value);
	            }
	            else if (typeOf === "object") {
	                if (Array.isArray(value)) {
	                    return consArray.from(value);
	                }
	                else if (value.constructor === Object) {
	                    return from(value);
	                }
	            }
	            // Else, return raw unsupported object.
	            return value;
	        },
	        set: function (oTarget, sKey, vValue) {
	            throw new errors_1.ReadonlyError("Setting an index or property on this Concrete object is forbidden.");
	        },
	        deleteProperty: function (oTarget, sKey) {
	            throw new errors_1.ReadonlyError("Deleting an index on this Concrete array is forbidden.");
	        },
	        defineProperty: function (oTarget, sKey, oDesc) {
	            throw new errors_1.ReadonlyError("Defining a property on this Concrete array is forbidden.");
	        },
	    });
	    // Add Array to cache.
	    return arr;
	}
	exports.from = from;
	//# sourceMappingURL=array.js.map

/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * The ReadonlyError is thrown during an attempt to change a Concrete object.
	 */
	var ReadonlyError = (function (_super) {
	    __extends(ReadonlyError, _super);
	    /**
	     * Constructs the ReadonlyError.
	     * @param message - the error message.
	     */
	    function ReadonlyError(message) {
	        var _this = _super.call(this, message) || this;
	        _this.name = "ReadonlyError";
	        return _this;
	    }
	    return ReadonlyError;
	}(Error));
	exports.ReadonlyError = ReadonlyError;
	//# sourceMappingURL=errors.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var guards_1 = __webpack_require__(2);
	var ConcreteStructure_1 = __webpack_require__(3);
	var errors_1 = __webpack_require__(5);
	var consArray = __webpack_require__(4);
	var consDate = __webpack_require__(7);
	var consMap = __webpack_require__(8);
	var consSet = __webpack_require__(9);
	var _1 = __webpack_require__(1);
	/**
	 *
	 */
	function toMutable(obj) {
	    var mutObj = {};
	    for (var key in obj) {
	        mutObj[key] = _1.toMutable(obj[key]);
	    }
	    return mutObj;
	}
	exports.toMutable = toMutable;
	/**
	 *
	 */
	function from(obj) {
	    obj = Object.defineProperty(obj, ConcreteStructure_1.ConcreteStructureTypeKey, {
	        value: ConcreteStructure_1.ConcreteStructureType.OBJECT
	    });
	    // Proxify
	    obj = new Proxy(obj, {
	        get: function (oTarget, sKey) {
	            var value = oTarget[sKey];
	            var typeOf = typeof value;
	            if (value === undefined || value === null || typeOf === "function" || typeOf === "symbol") {
	                return value;
	            }
	            // If already Concrete, return.
	            if (guards_1.is(value)) {
	                return value;
	            }
	            // If not Concrete and supported object, make Concrete.
	            if (value instanceof Map) {
	                return consMap.from(value);
	            }
	            else if (value instanceof Set) {
	                return consSet.from(value);
	            }
	            else if (value instanceof Date) {
	                return consDate.from(value);
	            }
	            else if (typeOf === "object") {
	                if (Array.isArray(value)) {
	                    return consArray.from(value);
	                }
	                else if (value.constructor === Object) {
	                    return from(value);
	                }
	            }
	            // Else, return raw unsupported object.
	            return value;
	        },
	        set: function (oTarget, sKey, vValue) {
	            throw new errors_1.ReadonlyError("Setting a property on this Concrete object is forbidden.");
	        },
	        deleteProperty: function (oTarget, sKey) {
	            throw new errors_1.ReadonlyError("Deleting a property on this Concrete object is forbidden.");
	        },
	        defineProperty: function (oTarget, sKey, oDesc) {
	            throw new errors_1.ReadonlyError("Defining a property on this Concrete object is forbidden.");
	        },
	    });
	    return obj;
	}
	exports.from = from;
	//# sourceMappingURL=object.js.map

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errors_1 = __webpack_require__(5);
	var ConcreteStructure_1 = __webpack_require__(3);
	var readOnlyErrorProp = {
	    value: function () { throw new errors_1.ReadonlyError("This method is not supported by ConcreteDate."); },
	};
	/**
	 *
	 */
	function from(date) {
	    date = Object.defineProperties(date, {
	        ConcreteStructureTypeKey: {
	            value: ConcreteStructure_1.ConcreteStructureType.DATE
	        },
	        setTime: readOnlyErrorProp,
	        setUTCMilliseconds: readOnlyErrorProp,
	        setSeconds: readOnlyErrorProp,
	        setUTCSeconds: readOnlyErrorProp,
	        setMinutes: readOnlyErrorProp,
	        setUTCMinutes: readOnlyErrorProp,
	        setHours: readOnlyErrorProp,
	        setUTCHours: readOnlyErrorProp,
	        setDate: readOnlyErrorProp,
	        setUTCDate: readOnlyErrorProp,
	        setMonth: readOnlyErrorProp,
	        setUTCMonth: readOnlyErrorProp,
	        setFullYear: readOnlyErrorProp,
	        setUTCFullYear: readOnlyErrorProp,
	        toMutable: function () {
	            return new Date(date.getTime());
	        },
	    });
	    date = new Proxy(date, {
	        set: function (oTarget, sKey, vValue) {
	            throw new errors_1.ReadonlyError("Setting a property on a ConcreteDate is forbidden.");
	        },
	        deleteProperty: function (oTarget, sKey) {
	            throw new errors_1.ReadonlyError("Deleting a property on a ConcreteDate is forbidden.");
	        },
	        defineProperty: function (oTarget, sKey, oDesc) {
	            throw new errors_1.ReadonlyError("Defining a property on a ConcreteDate is forbidden.");
	        },
	    });
	    return date;
	}
	exports.from = from;
	//# sourceMappingURL=date.js.map

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errors_1 = __webpack_require__(5);
	var ConcreteStructure_1 = __webpack_require__(3);
	var _1 = __webpack_require__(1);
	var readOnlyErrorProp = {
	    value: function () { throw new errors_1.ReadonlyError("This method is not supported by ConcreteMap."); },
	};
	/**
	 *
	 */
	function from(map) {
	    map.forEach(function (v, k) { return _1.from(v); }); // map.set(k, fromAll(v)));
	    map = Object.defineProperties(map, {
	        ConcreteStructureTypeKey: {
	            value: ConcreteStructure_1.ConcreteStructureType.MAP
	        },
	        clear: readOnlyErrorProp,
	        delete: readOnlyErrorProp,
	        set: readOnlyErrorProp,
	        toMutable: function () {
	            var mutMap = new Map();
	            map.forEach(function (v, k) { return mutMap.set(k, _1.toMutable(v)); });
	            return mutMap;
	        },
	    });
	    map = new Proxy(map, {
	        set: function (oTarget, sKey, vValue) {
	            throw new errors_1.ReadonlyError("Setting a property on a ConcreteDate is forbidden.");
	        },
	        deleteProperty: function (oTarget, sKey) {
	            throw new errors_1.ReadonlyError("Deleting a property on a ConcreteDate is forbidden.");
	        },
	        defineProperty: function (oTarget, sKey, oDesc) {
	            throw new errors_1.ReadonlyError("Defining a property on a ConcreteDate is forbidden.");
	        },
	    });
	    return map;
	}
	exports.from = from;
	//# sourceMappingURL=map.js.map

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errors_1 = __webpack_require__(5);
	var ConcreteStructure_1 = __webpack_require__(3);
	var _1 = __webpack_require__(1);
	var readOnlyErrorProp = {
	    value: function () { throw new errors_1.ReadonlyError("This method is not supported by ConcreteSet."); },
	};
	/**
	 *
	 */
	function from(set) {
	    set.forEach(function (v) { return _1.from(v); });
	    set = Object.defineProperties(set, {
	        ConcreteStructureTypeKey: {
	            value: ConcreteStructure_1.ConcreteStructureType.MAP
	        },
	        add: readOnlyErrorProp,
	        clear: readOnlyErrorProp,
	        delete: readOnlyErrorProp,
	        toMutable: function () {
	            var mutSet = new Set();
	            set.forEach(function (v) { return mutSet.add(_1.toMutable(v)); });
	            return mutSet;
	        },
	    });
	    set = new Proxy(set, {
	        set: function (oTarget, sKey, vValue) {
	            throw new errors_1.ReadonlyError("Setting a property on a ConcreteDate is forbidden.");
	        },
	        deleteProperty: function (oTarget, sKey) {
	            throw new errors_1.ReadonlyError("Deleting a property on a ConcreteDate is forbidden.");
	        },
	        defineProperty: function (oTarget, sKey, oDesc) {
	            throw new errors_1.ReadonlyError("Defining a property on a ConcreteDate is forbidden.");
	        },
	    });
	    return set;
	}
	exports.from = from;
	//# sourceMappingURL=set.js.map

/***/ }
/******/ ]);